				ULTIMATE INTRO TO PYGAME BY CLEAR CODE

Source: https://www.youtube.com/watch?v=AY9MnQ4x3zk&t=32s&ab_channel=ClearCode
Repo: https://github.com/clear-code-projects/UltimatePygameIntro

Esencialmente,un juego es parecido a una película,dado que en cada frame de ésta hay una imagen.El cerebro humano considera que es una imagen animada(movimiento) a partir de 24 frames per second.Asi pues podriamos decir que una pelicula es un monton de imagenes pasadas secuencialmente + los sonidos apropiados.

Hay tres formas de crear una película,la primera es grabar con una camara la realidad,la segunda es crear esas imagenes mediante un artista y la tercera es usar herramientas digitales.Al final acabariamos con un monton de imagenes que el cerebro interpretará como movimiento 

Los videojuegos son un poco diferentes,ya que las imagenes se pueden generar mientras el juego está ejecutandose(en una pelicula se quedan fijas,siempre será la misma secuencia de frames).Muchas cosas como la posición de los enemigos,del jugador,etc serán diferentes,o generadas al azar en un videojuego.
También hay un seguimiento constante de ciertas features,como la entrada del teclado,sprites,jugadores,enemigos,.. mientras que en una pelicula no hay seguimiento de nada.

A esto se le llama event loop,y son listeners que están siempre activos,como la entrada del teclado, o durante determinado tiempo.Normalmente se pintará algo en la UI con estos datos.Normalmente este ciclo se ejecuta 30 ó 60 veces por segundo(frames per second).Esto es independiente de si el juego es 2D o 3D.

					QUE HACE PYGAME EXACTAMENTE

Si bien Pygame se suele usar para crear games,también vale para cargar imagenes,etc.Entre sus features destacan:
1- Pygame me ayuda a dibujar imagenes/animaciones y a reproducir sonidos (algo que suele ser muy dificil y además ambas son  la base de los videojuegos)
2- Pygame comprueba iterativamente por I/O del usuario(usar el método input() del core de Python paraliza el código asi que es inviable en videojuegos ya que son animados)Ayuda mucho(o simplemente es necesario) en la entrada del teclado
3- Pygame también tiene otras herramientas para gamedev como colisiones,creación de textos,timers,...

Como downside ningun juego AAA ó 3D usará Pygame.En vez de eso usarán Game Engines,que son programas que ayudan a crear videojuegos con editores de niveles,motores de físicas,animaciones base,... UnrealEngine,Unity o Godot son ejemplos de ello.
Estas herramientas son indispensables ya que ayudan mucho al crear un videojuego.

¿Porqué aprender Pygame entonces y no ir al Game Engine directamente?Con pygame resolveré muchos problemas yo mismo y me convertiré en un mejor programador.Además pdré aprender cualquier herramienta adicional o el Game Engine desde una mejor posición.
Por el contrario,cuando use una Game Engine perderé flexibilidad ya que estoy atado a lo que me deje hacer ese motor de creación de videojuegos.
Asi pues es mejor cimentar buenas bases y despues moverse a cualquier Engine.

					EMPEZANDO CON PYGAME

Lo primero será instalarlo,ya que no viene con el core de Python.Sin embargo es un simple paquete a instalar con pip:
>pip install pygame

					 CREAR UNA VENTANA

Lo primero será importar la libreria.Despues, el método más importante es pygame.init() el cual inicia todo.Sin él no se puede hacer nada,no podŕe cargar imagenes,reproducir sonidos,...Además hay que llamarlo en primer lugar.

Para crear una ventana tengo que usar el método pygame.display.set_mode((width,height)) el cual lleva una tupla con el ancho y alto de la ventana(además de otros posibles argumentos) 

Sin embargo,si ejecuto el script veré que desaparece la ventana inmediatamente,ya que el script terminó inmediatamente.La solución es mantener el código ejecutandosé indefinidamente de alguna manera.Un bucle while True valdrá.Pero,ojo,dentro de él hay que llamar a pygame.display.update() para que re-renderize todo cada frame

* Sabiendo todo esto,ya puedo crear una ventana que se ejecute indefinidamente
import pygame

pygame.init()
screen = pygame.display.set_mode((800,400))
while True:
  pygame.display.update()

Sin embargo,el usuario no podrá cerrar esa ventana de ninguna forma,hay que programarlo.Para ello hay que iterar sobre todos los eventos posibles(para obtenerlos se usa pygame.event.get() y comprobar si es de tipo pygame.QUIT(esta constante es sinónima de pulsar la X en la ventana)

while True:
  for event in pygame.event.get():
    if event.type == pygame.QUIT:   <- la constante
      pygame.quit()
  pygame.display.update()

* Bien,ahora cierra la ventana,pero da un error 'video system not initialized'.Esto es porque pygame.quit() es lo contrario de pygame.init() y para todo,pero fijate que en el bucle la siguiente linea también será ejecutada y ese update dará un error ya que pygame.quit() ha parado todo.La solucion pues es usar el módulo system(el cual es parte del core y no tengo que importarlo) usando sys.exit()
Si bien podria usarse break o algo asi, lo mejor es usar el modulo system.

Asi pues,ya tengo todo el cascarón para crear una ventana,ya que todo esto es obligatorio.

import pygame
from sys import exit

pygame.init()
screen = pygame.display.set_mode((800,600))

while True:
  for event in pygame.event.get():
    if event.type == pygame.QUIT:
      pygame.quit()
      exit() <- también puedo usar sys.exit pero seria con import sys
  pygame.display.update()


DAR UN TITULO A LA VENTANA: obviamente,querré darle un título a la ventana.Para elo se usa el método pygame.display.set_caption(string)

				CONTROLLING THE FRAMERRATE

Esto es algo muy importante,si pongo muy alto el framerrate en una pc débil puede tener muchos fallos,o volverse injugable.Usar un framerrate constante a 60hz es lo ideal.Para ello hay que decirle al pc los framerrates máximos y mínimos(el máximo es muy sencillo,el mínimo no lo es).
Para controlar esto debo instanciar la clase Clock.Es un estandar llamar a la instancia 'clock':
clock = pygame.time.Clock()

Despues se accede al método de instancia tick(Number) para fijar el framerrate máximo(el mínimo lo dejamos por la complejidad,además siendo juegos 2D muy básicos no deberían tener problemas los pcs en ejecutarlos,etc...)
clock.tic(60) <- dentro del bucle while True,esto hará que el bucle se ejecute máximo 60 veces por segundo y el mínimo depende del equipo

				MINUTO 20 DISPLAYING IMAGES

Para dibujar cualquier tipo de imagen hay que entender el concepto de surface.Hay dos tipos de surfaces:
1- display surface: la ventana del juego.Debe ser única y estar siempre visible
2- regular surface: una única imagen,texto o color(importados).Puede haber varios(no hay límite) y sólo son visibles cuando se les asigne una display surface.

Veamos todo esto en la practica,con un plain color,una image y un text.
NOTA: para crear una surface se usa pygame.Surface((width,height)) <- tupla  

text_surface = pygame.Surface((100,200)).
* Y para agregarla a una surface se usa el método de instancia display-surface.blit(regular_surface,position).BLIT viene de BLockImageTransfer,lo cual sólo es una forma fancy de decir que quiero poner una regular surface en una display_surface

IMPORTANTE: pygame.display.set_mode((w,h)) devolvió una display_surface,ya que al crear la ventana principal obviamente creó la display_surface,luego para agregar la regular surface anterior:

screen = pygame.display.set_mode((800,400))
text_surface = pygame.Surface((100,200))
screen.blit(text_surface,(0,0)) <- obviamente position es una tupla

* Bien,puedo ver que no veo nada,lo cual tiene sentido ya que son dos fondos negros superpuestos.Asi que mejor les damos un color a cada superficie,para ello hay que usar el método de instancia surface.fill(color).

NOTA: pygame tiene varias formas de llamar a un color,por un string,por el hexadecimal.Fijate que de la version 1 a la 2 cambió un poco esto:
text_surface.fill(pygame.Color('Red') constantes capitalizadas
text_surface.fill(pygame.Color((255,0,0))) rgb
text_surface.fill(pygame.Color((255,0,0,0.6))) rgba

TIP:como siempre el punto 0,0 es la esquina superior izquierda,con lo que sumar al eje y es bajar y restar subir.
Bien,esto era solo un ejemplo.Importemos la imagen que hará de fondo(para importar una imagen se usa pygame.image.load(path_to_image):
sky_surface = pygame.image.load('graphics/Sky.png')
ground_surface = pygame.image.load('graphics/ground.png')

* Y los ubico con display_surface.blit(regular_surface,(pos)
screen.blit(sky_surface,(0,0))
screen.blit(ground_surface,(0,300))

CREATING TEXT: para crear texto es un tanto diferente.Hay que seguir 3 pasos:

1- crear una fuente(con tamaño,estilo,familia,...).Para ello se usa pygame.font.Font(family,size).Ejemplo: text = pygame.font.Font(None,50) <- 50px
* Aparte de None puedo usar una ruta a una fuente => pygame.font.Font('fonts/Pixeltype.ttf',50).
2- escribir texto en una surface.Para ello necesito la instancia anterior y el método render(texto,AntiAliasing,color).Ejemplo text_surface = text.render("Hola",False,'Red'). Fijate que el AA a true hará que el texto se vea un poco mejor.

3- ubicar la text_surface con blit()
screen.blit(text_surface,(100,100))

Con esto ya he aprendido a dibujar textos, a dibujar superficies, a rellenar superficies con color y a importar y mostrar imágenes.Esto son operaciones fundamentales en un videojuego,aunquea un videojuego no es nada sin movimientos

				ANIMACIONES BÁSICAS MINUTO 43

Ahora mismo tenemos tres surfaces,pero todas están en una posición estática.Para animar de forma muy básica una imagen basta con cambiar la posicion en el método blit y que no sea un number estático:
snail_surface = pygame.image.load('graphics/snail/snail1.png')
snail_x_position = 600

* Despues puedo meter en un bucle el screen.blit y además cuando desaparezca la imagen la puedo volver a cargar,creando un loop infinito
  if snail_x_position < -100: snail_x_position = 800
  screen.blit(snail_surface,(snail_x_position,250))

IMPORTANTE: si quitará todas las imagenes y dejara sólo el caracol sobre un fondo negro veré un efecto muy raro como que se estira la imagen.Esto es porque no tiene un background definido(o sea que la imagen que esté más al fondo es muy importante pues hace de fondo a las demás)

CONVERT_ALPHA: fijate que todo lo que he cargado son .png.Si además uso el método convert Pygame las cargará aún más rápido,ya que es algo que entiende mejor.Sin embargo esto no respetará el alpha asi que realmente lo que hay que usar es convert_alpha:

sky_surface = pygame.image.load('graphics/Sky.png').convert_alpha()
ground_surface = pygame.image.load('graphics/ground.png').convert_alpha()
snail_surface = pygame.image.load('graphics/snail/snail1.png').convert_alpha()

Resumen: cambiar en el blit los valores de una imagen crea una animación muy básica y es mejor convertir cada imagen que se cargue para mejor eficiencia

					RECTANGLES M 51

Los rectangúlos son muy importantes en un videojuego.Tienen dos objetivos básicos:
1- posicionamiento preciso de superficies
2- ayudan en la deteción de colisiones

NOTA: los rectangles en pygame tienen 9 posiciones ya dadas(son todas tuplas):
 topleft        midtop       topright
 midleft        center       midright
 bottomleft     midbottom    bottomright

NOTA: los rectangles se crean con pygame.Rect(left,top,width,height),pero también puedo sacar el rectangulo de una superficie con get_rect:

player_surface = pygame.image.load(path).convert_alpha
player_rect = player_surface.get_rect(midbottom = (80,300) 

TIP: más adelante veré que la combinación de una surface + un rect realmente es un sprite,incluso está esa clase y hay un montón de métodos para ella,pero es mejor entender que es un sprite realmente

IMPORTANTE: y ahora que tengo esa imagen en un rectangulo puedo mover el rectangulo y asi mover la imagen de su interior:

player_rect.left += 2

Asi es como se mueve algo en pygame,no se mueve la surface sino el rect que contiene la surface.Y no solo esto,sino que puedo imprimirla para hacer calculos:
print(player_rect.left,player_rect.top,etc...)

					COLLISIONS WITH RECTANGLES

 Para crear colisiones puedo usar el método de instancia rect1.colliderect(rect2) ,el cual comprobará si el rect1 colisiona con el 2.El método retorna 0 si no hay colision o 1 si si la hay(parece que ahora devuelve False y True .  
NOTA: python convierte automáticamente 0 y 1 a False y True asi que realmente da igual que retorne 0 y 1 o False y True
IMPORTANTE: la comprobación se hace por cada frame.

NOTA: hay otro tipo de método que puedo usar y es rect1.collidepoint((x,y)).No lo vamos a usar mucho pero es muy importante también.Simplemente comprueba si un punto colisiona con el rectangulo dado.
Esto es algo que se hace mucho cuando se juega con el ratón

				GETTING THE MOUSE POSITION

Para obtener la posiciòn del mouse del usuario puedo usar dos approach.O bien uso pygame.mouse o event loop.
El primero, pygame.mouse, retorna mucha información sobre el mouse, como la position,los clicks,los buttons,la visibility...
El segundo, event loop, básicamente obtiene lo mismo(menos la visibility??), asi que ambas formas son completamente válidas.

* Sabiendo todo esto puedo obtener la posición del mouse y comprobar si el puntero choca con el player,ie:
mouse_pos = pygame.mouse.get_pos() <- devuelve la lista(x,y)
if player_rect.collidepoint(mouse_pos): <- recuerda que pide una lista(x,y)
  print('mouse collision against player') <- fijate que facil es saber si el puntero choca con algo.

NOTA: y para saber si los botones estan siendo pulsados tengo pygame.mouse.get_pressed() que devuelve [Boolean,Boolean,Boolean] para los dos botones y la ruedecilla del mouse del usuario.

La otra forma sería mirando por el evento:
  if event.type == pygame.MOUSEMOTION:
      print(event.pos)
Y lo mismo para los botones:
 if event.type == pygame.MOUSEBUTTONDOWN | MOUSEBUTTONUP <- para onRelease

IMPORTANTE: puedo meter un texto en un rect también,no sólo una imagen:
text_font = pygame.font.Font('font/Pixeltype.ttf',50)
score_surf = text_font.render("Score",False,'Black')
score_rect = score_surf.get_rect(center = (400,50))

		USING RECTANGLES TO DRAW- MODULE PYGAME.DRAW 1H18M

En pygame hay un módulo muy importante llamado draw,el cual puede dibujar rectangles,circles,lines,points,ellipses,etc.Casi siempre será con pygame.draw. y la figura,es decir:

pygame.draw.rect() <- dibuja un rectangle
pygame.draw.poligon()
pygame.draw.circle()
pygame.draw.arc()
* Obviamente unos llevarán más argumentos que otros.Dibujemos un rect pues 
  pygame.draw.rect(screen,'Pink',score_rect)
  pygame.draw.rect(screen,'Pink',score_rect,6) <- en cuanto use el cuarto argumento que es el line width ya no rellenará el cuadrado por eso hay que repetir dos veces el rect

Y por ejemplo una linea:
 pygame.draw.line(screen,'Pink',(0,0),(800,400),6)

Una ellipsis que será un circulo:
pygame.draw.ellipse(screen,'Brown',pygame.Rect(50,200,100,100))

			COLORS 1H25

Hay dos formas de especificar colores en pygame(y en casi cualquier otro sitio).Una es con rgb y otra con hexadecimal
Si uso hexadecimal me vale un string:
pygame.draw.rect(screen,'#c0e8ec',score_rect)
Si uso rgb tiene que ser una lista:
score_surf = text_font.render("Score",False,(64,64,64))

				 THE PLAYER CHARACTER 1H30M		

El player es probablemente lo más importante de un game.Querremos varias cosas de él en este juego:
1- keyboard input to move it(leer las teclas)
2- jump + gravity(dado que saltará)
3- creating a floor(no puede caer al infinito)

De nuevo para leer el teclado tengo dos formas,una es mediante el módulo pygame.key y el otro capturando el evento en el event loop.Veamoslo en código:

keys = pygame.key.get_pressed() <- este método devuelve una tupla inmensa con todas las teclas y su valor en formato False/True(ó 0 y 1).Dado que ellos ya han creado una constante para cada tecla puedo usar esto:
if keys[pygame.K_SPACE]: <- fijate que siempre será pygame.K_XXX
  do something

En cuanto a usarlo en el bucle for event in pygame.event.get() primero miro por el vento KEYDOWN y despues por la key con la misma constante:
    if event.type == pygame.KEYDOWN:
      if event.key == pygame.K_ESCAPE: print("jump")

* Hay dos formas de capturar las teclas porque en un juego normal usaré clases y alli tengo que usar los módulos pygame.key y pygame.mouse en vez de bucles.

					JUMPING AND GRAVITY

Dado que una caida no lleva una velocidad lineal,sino exponencial hay que tener mucho cuidado con cualquier movimiento que acelera o decelera incrementalmente
Realmente es muy sencillo esto,sólo hay que usar dos incrementales:
gravity += some value
player.y += gravity <- cada vez será un poco más

Tampoco es muy importante que las physics sean accurate al 100%.
player_gravity = 0
if event.type == pygame.MOUSEBUTTONDOWN:
  if player_rect.collidepoint(event.pos): 
    player_gravity = -20
*En el bucle
player_gravity += 1
player_rect.bottom += player_gravity

Ya tenemos el salto,claro que cae indefinidamente.Vamos a crear el suelo de una forma muy sencilla(si el player.bottom > 300 player.bottom = 300)
NOTA: realmente no estamos mirando que haya una collision contra el suelo,es algo muy básico.

				GAME OVER STATE - DIFERENTES STATES 1H 48M

Queremos que el player no pueda tocar el caracol.Si lo hace se acaba el juego.De aqui podemos ver que hay dos estados(game over y game playing).Realmente es bastante sencillo parar todo el bucle que es el juego,metiendolo en un if/else:
if game_active:
  .... all logic
else:
  game_over

De nuevo esto es bastante básico y no es lo mejor para un juego complejo.

				DISPLAYING THE SCORE 1H 56M

Para crear un marcador correctamente necesito:
1- actualizar el score en cada frame
2- ponerlo en una surface
3- mostrar esa surface

Para ello lo primero es obtener el tiempo actual,lo tengo en pygame.time.get_ticks(),el cual devuelve los ms actuales.Fijate que si lo meto en el bucle while se eejecutará cada frame,pero si no está en un bucle simplemente devuelve una vez ls milisegundos actuales

TIP: puedo convertir a string de varias maneras.
1- str(current_time)
2- (f'{current_time}') <- fijate que es f'{}' el format siempre sobre el string

* Puedo observar que ver los ms es una información que cambia muy rápido.

  def display_score(self):
    current_time = int(pygame.time.get_ticks() / 1000) - self.start_time
    self.score_surf = self.text_font.render(f'Score {current_time}',False,(64,64,64))    
    self.score_rect = self.score_surf.get_rect(center = (400,50))

				IMPROVING THE GAME OVER SCREEN 2H 05M

Queremos mejorar la pantalla de game over.Para ello hay que aprender como transformar surfaces(como escalarlas,rotarlas,...)Y para realizar esto está el módulo pygame.transform y sus métodos:
pygame.transform.flip: flip vertically and horizontally
pygame.transform.rotate: rotate an image
pygame.transform.scale: resize to new resolution
... 

De momento usaremos scale(surface,(newWidht,newHeightS)) aunque se suele escalar con smoothscale,etc que será más costoso pero más correcto
Fijate que scale2x(surface) también es muy usado y simplemente dobla la surface

También pygame.transform.rotozoom(surface,angle,scale) combina scale y rotation y es muy usado:
self.player_standing_surf = pygame.transform.rotozoom(self.player_standing_surf,0,2)
Este método parece ofrecer un mejor algoritmo de escalado asi que lo usaremos sobre scale.Fijate que además sería muy sencillo meter un angle de rotation de la image.

Fijate que Python se parece mucho a JS ya que las def puedo omitir el return(pero devuelven return None,ojo):
  def create_standing_player(self):
    self.player_standing_surf = pygame.image.load('graphics/Player/player_stand.png').convert_alpha()
    # self.player_standing_surf = pygame.transform.scale(self.player_standing_surf,(150,150))
    self.player_standing_surf = pygame.transform.rotozoom(self.player_standing_surf,0,2)
    self.player_standing_rect = self.player_standing_surf.get_rect(center = (400,200))
    return (self.player_standing_surf, self.player_standing_rect)
  
  def create_game_over_UI(self):
    self.text_font = pygame.font.Font('font/Pixeltype.ttf',50) 
    self.game_title_surf = self.text_font.render("Pixel Runner",False,(111,196,169))
    self.game_title_rect = self.game_title_surf.get_rect(center = (410,80))
    self.game_message = self.text_font.render("Press space to run",False,(111,196,169))
    self.game_message_rect = self.game_message.get_rect(center = (410,340))
    return(self.game_title_surf, self.game_title_rect, self.game_message, self.game_message_rect)

					2H 20M DISPLAYING SCORE

Para poder acceder al score desde esa zona que muestra la pantalla de game over tengo dos opciones.La primera es declarar una variable global:

def display_score():
  global current_time
  current_time: int(pygame.time.get_ticks() / 1000) start_time

La segunda es haciendo que la funcion retorne ese valor con un return y despues metiendo la llamada a la funcion en otra variable.

def display_score():
  current_time: int(pygame.time.get_ticks() / 1000) start_time
  return current_time

from_other_file = display_score()

						TIMERS 2H 25M

We want another enemy in the game.Para ello tendré que seguir varios pasos:
1- Create a custom event
2- Tell pygame to trigger that event continously
3- Add code in the event loop to do what I need

NOTA: fijate que fácil era cambiar las surfaces mirando por la posición en el eje y:

  def create_enemies(self):
    # for enemy_rect in self.level.enemies_list:
    if(self.level.enemies):
      for enemy_rect in self.level.enemies['rects']:
        enemy_rect.x -= 5
        if enemy_rect.bottom == 300:
          self.screen.blit(self.level.snail_surf, enemy_rect)
        else:
          self.screen.blit(self.level.fly_surf, enemy_rect)
          # list comprehension(x for x in list if ...):  
      self.level.enemies_list = [enemy_rect for enemy_rect in self.level.enemies_list if enemy_rect.x > -100]
      
    return self.level.enemies_list

Cuando choque el player queremos resetear la gravity,la posición y la lista de coolider_rects de los enemies,para que no choque inmediatamente en el siguiente frame:
  self.level.enemies_list.clear() 
        self.level.player_rect.midbottom = (80,300)
        self.level.player_gravity = 0

			ANIMATE THE PLAYER,THE FLY AND THE SNAIL 2h50m

Si consigo animar los sprites será algo que quede muy bien,una gran mejora.Un juego con animaciones siempre luce mucho mejor que con sprites estáticos
Haremos algo muy básico,simplemente cambiaremos el sprite cada ciertos ms.

Para hacer esto usaremos nuestro propio timer si se trata de la animation del player,pero we will rely on the inbuild timers to update enemies surfaces/sprites.

Lo primero es declarar todo lo necesario.
  def create_player(self):
    player_walk_1 = pygame.image.load('graphics/Player/player_walk_1.png').convert_alpha()
    player_walk_2 = pygame.image.load('graphics/Player/player_walk_2.png').convert_alpha()
    self.player_walk = [player_walk_1, player_walk_2]
    self.player_index = 0
    self.player_jump = pygame.image.load('graphics/Player/jump.png').convert_alpha()
    self.player_surf = self.player_walk[self.player_index]
    self.player_rect = self.player_surf.get_rect(midbottom = (80,300)) 

Despues creo el método:
  def player_animation(self):
    global player_surf,player_index
    # si no toca el suelo cambio el sprite
    if self.level.player_rect.bottom < 300:
      self.level.player_surf = self.level.player_jump
    else:
      self.level.player_index += 0.1
      self.level.player_surf = self.level.player_walk[int(self.level.player_index) % len(self.level.player_walk)]

Para los enemigos es un poco más complejo,ya que no solo hay uno

						SPRITES 3H 10M

Lo primero es entender que un sprite es la unión de una image + el rectangle.Al usar un sprite manejaré de forma más sencillas los enemies,el player,etc.
Hay varios tipos de sprite,el jugador va a estar en un grupo con una single sprite(pues es siempre el mismo player) mientras que los enemies van a necesitar una sprite diferente cada uno).Esto se hace para detectar las colisiones,cada enemy tiene una collisionrect diferente,mientras que el player es la misma.

IMPORTANTE: los Sprites tienen dos funcionalidades claras.La primera es reducir código al ser la unión de la image + el rect para las colisiones,etc, pero la segunda es poder ejecutar el método update sobre ellos en vez de llamar a cada método suyo individualmente.
Al final creo el sprite eligiendo un grupo y despues le paso una instancia con add:

self.player = pygame.sprite.SingleGroup()
self.player.add(Player()) <-le paso la instancia de Player 

Ahora,puedo crear un método update en la clase Player que llame a todos los demás de la clase y llamarlo con self.player.update(),llamando pues a todos(es como un init().Genial.

Fijate que se convierte en un juego de niños en cuanto uso Sprites:
* Para moverlo
  def update(self):
    self.animation_state()
    self.rect.x -= 5
* Para destruirlo tengo el método kill por ser un Sprite
  def destroy(self):
    if self.rect.x <= -100:
      self.kill()

		COLLISIONS CON SPRITES == SPRITECOLLIDE(sprite,group,dokill)

Afortunadamente manejar las colisiones es también muy sencillo con la clase Sprite,ya que tiene su propio método spritecollide(sprite) el cual toma un sprite y mira a ver si está colisionando con cualquier otro grupo de sprites.Si choca lo que hace es retornar una lista de todos los Sprites con los que colisiona.
NOTA: hay más métodos para manejar colisiones con Sprites,pero éste es el más usado.

Siendo tan simple puedo hacer esto:

  def collision_sprite(self):
    if pygame.sprite.spritecollide(self.player.sprites()[0],self.obstacles_group,False):
      # para que no vuelva a chocar con el Sprite al reiniciar
      self.obstacles_group.empty() 
      return False
    else: return True

Fijate que tmb podia haber accedido con self.player.sprite pues es un SingleGroup,pero si fuera un Group tengo que acceder mediante sprites().
Desde luego es mucho más simple
Recuerda que spritecollide devuelve una lista,entiendo que está mirando si esta con elementos o no.

IMPORTANTE: y fijate que rápido eliminé un grupo de Sprites con instancia.empty().Increible.

						ADDING MUSIC/SOUNDSC 3H 43M

Realmente esta parte va a ser muy sencilla.Solo vamos a tener dos sonidos,la musica de background y cuando salte el player.

Para importar un sonido se usa el modulo mixer y la clase Sound.Fijate que puedo regular el volumen si lo traigo muy fuerte:

self.jump_sound = pygame.mixer.Sound('audio/jump.mp3')
self.jump_sound.set_volume(0.5) # rango entre 0 y 1

Despues simplemente lo reproduzco con instancia.play():
    if keys[pygame.K_SPACE] and self.rect.bottom >= 300:
      self.gravity = -20
      self.jump_sound.play()

Y para dejar el sonido infinito le pongo las loops a -1:
 self.bg_music = pygame.mixer.Sound('audio/music.wav')
    self.bg_music.play(loops = -1)
Recuerda que puedo pararlo con stop()cuando salga,etc...
Desde luego ha sido un gran tutorial



