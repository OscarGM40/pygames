				ULTIMATE INTRO TO PYGAME BY CLEAR CODE

Source: https://www.youtube.com/watch?v=AY9MnQ4x3zk&t=32s&ab_channel=ClearCode
Repo: https://github.com/clear-code-projects/UltimatePygameIntro

Esencialmente,un juego es parecido a una película,dado que en cada frame de ésta hay una imagen.El cerebro humano considera que es una imagen animada(movimiento) a partir de 24 frames per second.Asi pues podriamos decir que una pelicula es un monton de imagenes pasadas secuencialmente + los sonidos apropiados.

Hay tres formas de crear una película,la primera es grabar con una camara la realidad,la segunda es crear esas imagenes mediante un artista y la tercera es usar herramientas digitales.Al final acabariamos con un monton de imagenes que el cerebro interpretará como movimiento 

Los videojuegos son un poco diferentes,ya que las imagenes se pueden generar mientras el juego está ejecutandose(en una pelicula se quedan fijas,siempre será la misma secuencia de frames).Muchas cosas como la posición de los enemigos,del jugador,etc serán diferentes,o generadas al azar en un videojuego.
También hay un seguimiento constante de ciertas features,como la entrada del teclado,sprites,jugadores,enemigos,.. mientras que en una pelicula no hay seguimiento de nada.

A esto se le llama event loop,y son listeners que están siempre activos,como la entrada del teclado, o durante determinado tiempo.Normalmente se pintará algo en la UI con estos datos.Normalmente este ciclo se ejecuta 30 ó 60 veces por segundo(frames per second).Esto es independiente de si el juego es 2D o 3D.

					QUE HACE PYGAME EXACTAMENTE

Si bien Pygame se suele usar para crear games,también vale para cargar imagenes,etc.Entre sus features destacan:
1- Pygame me ayuda a dibujar imagenes/animaciones y a reproducir sonidos (algo que suele ser muy dificil y además ambas son  la base de los videojuegos)
2- Pygame comprueba iterativamente por I/O del usuario(usar el método input() del core de Python paraliza el código asi que es inviable en videojuegos ya que son animados)Ayuda mucho(o simplemente es necesario) en la entrada del teclado
3- Pygame también tiene otras herramientas para gamedev como colisiones,creación de textos,timers,...

Como downside ningun juego AAA ó 3D usará Pygame.En vez de eso usarán Game Engines,que son programas que ayudan a crear videojuegos con editores de niveles,motores de físicas,animaciones base,... UnrealEngine,Unity o Godot son ejemplos de ello.
Estas herramientas son indispensables ya que ayudan mucho al crear un videojuego.

¿Porqué aprender Pygame entonces y no ir al Game Engine directamente?Con pygame resolveré muchos problemas yo mismo y me convertiré en un mejor programador.Además pdré aprender cualquier herramienta adicional o el Game Engine desde una mejor posición.
Por el contrario,cuando use una Game Engine perderé flexibilidad ya que estoy atado a lo que me deje hacer ese motor de creación de videojuegos.
Asi pues es mejor cimentar buenas bases y despues moverse a cualquier Engine.

					EMPEZANDO CON PYGAME

Lo primero será instalarlo,ya que no viene con el core de Python.Sin embargo es un simple paquete a instalar con pip:
>pip install pygame

					 CREAR UNA VENTANA

Lo primero será importar la libreria.Despues, el método más importante es pygame.init() el cual inicia todo.Sin él no se puede hacer nada,no podŕe cargar imagenes,reproducir sonidos,...Además hay que llamarlo en primer lugar.

Para crear una ventana tengo que usar el método pygame.display.set_mode((width,height)) el cual lleva una tupla con el ancho y alto de la ventana(además de otros posibles argumentos) 

Sin embargo,si ejecuto el script veré que desaparece la ventana inmediatamente,ya que el script terminó inmediatamente.La solución es mantener el código ejecutandosé indefinidamente de alguna manera.Un bucle while True valdrá.Pero,ojo,dentro de él hay que llamar a pygame.display.update() para que re-renderize todo cada frame

* Sabiendo todo esto,ya puedo crear una ventana que se ejecute indefinidamente
import pygame

pygame.init()
screen = pygame.display.set_mode((800,400))
while True:
  pygame.display.update()

Sin embargo,el usuario no podrá cerrar esa ventana de ninguna forma,hay que programarlo.Para ello hay que iterar sobre todos los eventos posibles(para obtenerlos se usa pygame.event.get() y comprobar si es de tipo pygame.QUIT(esta constante es sinónima de pulsar la X en la ventana)

while True:
  for event in pygame.event.get():
    if event.type == pygame.QUIT:   <- la constante
      pygame.quit()
  pygame.display.update()

* Bien,ahora cierra la ventana,pero da un error 'video system not initialized'.Esto es porque pygame.quit() es lo contrario de pygame.init() y para todo,pero fijate que en el bucle la siguiente linea también será ejecutada y ese update dará un error ya que pygame.quit() ha parado todo.La solucion pues es usar el módulo system(el cual es parte del core y no tengo que importarlo) usando sys.exit()
Si bien podria usarse break o algo asi, lo mejor es usar el modulo system.

Asi pues,ya tengo todo el cascarón para crear una ventana,ya que todo esto es obligatorio.

import pygame
from sys import exit

pygame.init()
screen = pygame.display.set_mode((800,600))

while True:
  for event in pygame.event.get():
    if event.type == pygame.QUIT:
      pygame.quit()
      exit() <- también puedo usar sys.exit pero seria con import sys
  pygame.display.update()


DAR UN TITULO A LA VENTANA: obviamente,querré darle un título a la ventana.Para elo se usa el método pygame.display.set_caption(string)

				CONTROLLING THE FRAMERRATE

Esto es algo muy importante,si pongo muy alto el framerrate en una pc débil puede tener muchos fallos,o volverse injugable.Usar un framerrate constante a 60hz es lo ideal.Para ello hay que decirle al pc los framerrates máximos y mínimos(el máximo es muy sencillo,el mínimo no lo es).
Para controlar esto debo instanciar la clase Clock.Es un estandar llamar a la instancia 'clock':
clock = pygame.time.Clock()

Despues se accede al método de instancia tick(Number) para fijar el framerrate máximo(el mínimo lo dejamos por la complejidad,además siendo juegos 2D muy básicos no deberían tener problemas los pcs en ejecutarlos,etc...)
clock.tic(60) <- dentro del bucle while True,esto hará que el bucle se ejecute máximo 60 veces por segundo y el mínimo depende del equipo

				MINUTO 20 DISPLAYING IMAGES

Para dibujar cualquier tipo de imagen hay que entender el concepto de surface.Hay dos tipos de surfaces:
1- display surface: la ventana del juego.Debe ser única y estar siempre visible
2- regular surface: una única imagen,texto o color(importados).Puede haber varios(no hay límite) y sólo son visibles cuando se les asigne una display surface.

Veamos todo esto en la practica,con un plain color,una image y un text.
NOTA: para crear una surface se usa pygame.Surface((width,height)) <- tupla  

text_surface = pygame.Surface((100,200)).
* Y para agregarla a una surface se usa el método de instancia display-surface.blit(regular_surface,position).BLIT viene de BLockImageTransfer,lo cual sólo es una forma fancy de decir que quiero poner una regular surface en una display_surface

IMPORTANTE: pygame.display.set_mode((w,h)) devolvió una display_surface,ya que al crear la ventana principal obviamente creó la display_surface,luego para agregar la regular surface anterior:

screen = pygame.display.set_mode((800,400))
text_surface = pygame.Surface((100,200))
screen.blit(text_surface,(0,0)) <- obviamente position es una tupla

* Bien,puedo ver que no veo nada,lo cual tiene sentido ya que son dos fondos negros superpuestos.Asi que mejor les damos un color a cada superficie,para ello hay que usar el método de instancia surface.fill(color).

NOTA: pygame tiene varias formas de llamar a un color,por un string,por el hexadecimal.Fijate que de la version 1 a la 2 cambió un poco esto:
text_surface.fill(pygame.Color('Red') constantes capitalizadas
text_surface.fill(pygame.Color((255,0,0))) rgb
text_surface.fill(pygame.Color((255,0,0,0.6))) rgba

TIP:como siempre el punto 0,0 es la esquina superior izquierda,con lo que sumar al eje y es bajar y restar subir.
Bien,esto era solo un ejemplo.Importemos la imagen que hará de fondo(para importar una imagen se usa pygame.image.load(path_to_image):
sky_surface = pygame.image.load('graphics/Sky.png')
ground_surface = pygame.image.load('graphics/ground.png')

* Y los ubico con display_surface.blit(regular_surface,(pos)
screen.blit(sky_surface,(0,0))
screen.blit(ground_surface,(0,300))

CREATING TEXT: para crear texto es un tanto diferente.Hay que seguir 3 pasos:

1- crear una fuente(con tamaño,estilo,familia,...).Para ello se usa pygame.font.Font(family,size).Ejemplo: text = pygame.font.Font(None,50) <- 50px
* Aparte de None puedo usar una ruta a una fuente => pygame.font.Font('fonts/Pixeltype.ttf',50).
2- escribir texto en una surface.Para ello necesito la instancia anterior y el método render(texto,AntiAliasing,color).Ejemplo text_surface = text.render("Hola",False,'Red'). Fijate que el AA a true hará que el texto se vea un poco mejor.

3- ubicar la text_surface con blit()
screen.blit(text_surface,(100,100))

Con esto ya he aprendido a dibujar textos, a dibujar superficies, a rellenar superficies con color y a importar y mostrar imágenes.Esto son operaciones fundamentales en un videojuego,aunquea un videojuego no es nada sin movimientos

				ANIMACIONES BÁSICAS MINUTO 43

Ahora mismo tenemos tres surfaces,pero todas están en una posición estática.Para animar de forma muy básica una imagen basta con cambiar la posicion en el método blit y que no sea un number estático:
snail_surface = pygame.image.load('graphics/snail/snail1.png')
snail_x_position = 600

* Despues puedo meter en un bucle el screen.blit y además cuando desaparezca la imagen la puedo volver a cargar,creando un loop infinito
  if snail_x_position < -100: snail_x_position = 800
  screen.blit(snail_surface,(snail_x_position,250))

IMPORTANTE: si quitará todas las imagenes y dejara sólo el caracol sobre un fondo negro veré un efecto muy raro como que se estira la imagen.Esto es porque no tiene un background definido(o sea que la imagen que esté más al fondo es muy importante pues hace de fondo a las demás)

CONVERT_ALPHA: fijate que todo lo que he cargado son .png.Si además uso el método convert Pygame las cargará aún más rápido,ya que es algo que entiende mejor.Sin embargo esto no respetará el alpha asi que realmente lo que hay que usar es convert_alpha:

sky_surface = pygame.image.load('graphics/Sky.png').convert_alpha()
ground_surface = pygame.image.load('graphics/ground.png').convert_alpha()
snail_surface = pygame.image.load('graphics/snail/snail1.png').convert_alpha()

Resumen: cambiar en el blit los valores de una imagen crea una animación muy básica y es mejor convertir cada imagen que se cargue para mejor eficiencia

					RECTANGLES M 51

Los rectangúlos son muy importantes en un videojuego.Tienen dos objetivos básicos:
1- posicionamiento preciso de superficies
2- ayudan en la deteción de colisiones

NOTA: los rectangles en pygame tienen 9 posiciones ya dadas(son todas tuplas):
 topleft        midtop       topright
 midleft        center       midright
 bottomleft     midbottom    bottomright

NOTA: los rectangles se crean con pygame.Rect(left,top,width,height),pero también puedo sacar el rectangulo de una superficie con get_rect:

player_surface = pygame.image.load(path).convert_alpha
player_rect = player_surface.get_rect(midbottom = (80,300) 

TIP: más adelante veré que la combinación de una surface + un rect realmente es un sprite,incluso está esa clase y hay un montón de métodos para ella,pero es mejor entender que es un sprite realmente

IMPORTANTE: y ahora que tengo esa imagen en un rectangulo puedo mover el rectangulo y asi mover la imagen de su interior:

player_rect.left += 2

Asi es como se mueve algo en pygame,no se mueve la surface sino el rect que contiene la surface.Y no solo esto,sino que puedo imprimirla para hacer calculos:
print(player_rect.left,player_rect.top,etc...)

					COLLISIONS WITH RECTANGLES


  
