				ZELDA STYLE GAME WITH PYGAMES LIB BY CLEAR-CODE

Source: https://www.youtube.com/watch?v=QU1pPzEGrqw&ab_channel=ClearCode
Repo: https://github.com/clear-code-projects/Zelda

					MINUTO 40 COLLISIONS

COLLISIONS: pygame puede decirme si ha ocurrido una colisión,pero no en que lado del sprite.Afortunadamente se puede solucionar,pero hay que tener esto en cuenta en pygame la direccion:
 
 def collision(self,direction):
    if direction == 'horizontal':
      pass <- haré algo
    if direction == 'vertical':
      pass <- haré otra cosa
Buscar el método collision en la clase Player para la impl.
También hubo que retocar def move:
  def move(self,speed):
    #si se mueve en diagonal hay que normalizar speed
    if self.direction.magnitude() != 0:
      self.direction = self.direction.normalize()
    # no uso self.speed ya que valdrá para mover cualquier cosa
    self.rect.x += self.direction.x * speed
    self.collision('horizontal')
    self.rect.y += self.direction.y * speed
    self.collision('vertical')
Más tarde crearemos un pequeño gap para que no se pare exactamente cuando empieza el sprite y dé la sensación de que hace overlap entre el sprite del player y el
del obstacle.
  
				MINUTO 50 CREATING THE CAMERA

NOTA: puedo conseguir la camara y el overlap anterior customizando un group.Hasta ahora sólo habiamos usado los grupos para:
1- Almacenar y dibujar sprites
2- Llamar al método update
* Sin embargo puedo añadir métodos o cambiar como funcionan los grupos

Fijate que es aqui donde los usé(level.py):
    # sprites group setup(visibles y colisionables)
    self.visible_sprites = pygame.sprite.Group()
    self.obstacle_sprites = pygame.sprite.Group()

Con todo esto puedo crear una clase para la Camara que herede de un Group:

class YSortCameraGroup(pygame.sprite.Group):  #extiende de Group
  def __init__(self):
    # general setup
    super().__init__()
    self.display_surface = pygame.display.get_surface()
    # saco los dos centros
    self.half_width = self.display_surface.get_size()[0] // 2
    self.half_height = self.display_surface.get_size()[1] // 2
    self.offset = pygame.math.Vector2()
    
  def custom_draw(self,player):
    # getting the offset
    self.offset.x = player.rect.centerx - self.half_width
    self.offset.y = player.rect.centery - self.half_height

    for sprite in self.sprites():
      offset_pos = sprite.rect.topleft - self.offset
      self.display_surface.blit(sprite.image,offset_pos)

			MINUTO 1H01 ADDING THE OVERLAP

Each sprite gets a hitbox for the collision.Nuestro objetivo es reducir un poco el hitbox para la collision con el player(a su cuerpo)
Para ello usaré inflate(x,y) que reduce el tamaño de un rectángulo:
self.hitbox = self.rect.inflate(0,-10) 
Aun faltó los overlaps.

			MINUTO 1H 10 USING PROPER GRAPHICS

En este punto el autor recalca que tiene un tutorial con Tiled(Un editor de screens para 2D).Es el tutorial de Mario.Esta sección será muy extensa:
1-La imagen
TIP: puedo caminar por el file system en python con el método walk de la lib os:
from os import walk

def import_folder(path):  
  for data in walk(path):
    print(data)

import_folder('./zelda-graphics/1 - level/map')

Pero,ojo,walk me devuelve tres argumentos,primero el nombre del folder,no lo quiero,despues una list con los subfolders(viene una empty tuple[] ya que no hay),y como tercero viene una lista de files,que si quiero.Fijate que necesitaré combinar el path inicial con cada arg de la lista para crear el path completo para automatizar los imports:
for _,__,files in walk(path): <- fijate como ha ignorado con _ y despues __(cada vez un guion más.

			1H 56 PROPER PLAYER GRAPHICS AND ANIMATIONS

Turno del sprite para el player.Lo primero de todo es entender que el jugador va a tener varios estados(12 en total):
4 x idle,4 x walk, 4 x attack (los 4 son => izd | der | arri | aba) 
 Básicamente según el estado realizará una animación(habrá que importarlas pues).
También tendrá la habilidad de atacar y de lanzar hechizos

Para el ataque fisico y mágico necesitaré unos cooldowns:
Propiedades de PLAYER
    self.attacking = False
    self.attack_cooldown = 400
    self.attack_time = None

En def input(self)
    # attack input
    if keys[pygame.K_SPACE] and not self.attacking:
      self.attacking = True
      self.attack_time = pygame.time.get_ticks() 
    # magic input
    if keys[pygame.K_LCTRL] and not self.attacking:
      self.attacking = True
      self.attack_time = pygame.time.get_ticks() 

  def cooldowns(self):
    current_time = pygame.time.get_ticks() # este se llama multiples veces
    if self.attacking:
      if current_time - self.attack_time > self.attack_cooldown:
        self.attacking = False
        self.attack_time = None
    
NOTA: cada animación van a ser 5 sprites.Una vez dilucidado el status del player habrá que cargar esa secuencia de imagenes 
  def animate(self):
    animation = self.animations[self.status] # esto me da una lista o array
    # loop over the frame indexes
    self.frame_index += self.animation_speed
    if self.frame_index >= len(animation): # volver a empezar la animation
      self.frame_index = 0
    # set the image
    self.image = animation[int(self.frame_index)]
    self.rect = self.image.get_rect(center = self.hitbox.center) # hay que actualizar el cento por la diferencia de tamaño de las images

				2H30M WEAPONS

Básicamente crearemos un sprite cuando el jugador ataque y lo destruiremos cuando termine de atacar.
Para ello vamos a crear la clase Weapon en weapon.py, y al crear el player le pasamos una funcion create_attack:
self.player = Player((2000,1430),[self.visible_sprites],self.obstacle_sprites,self.create_attack)
          
def create_attack(self):
  Weapon(self.player,[self.visible_sprites]) 
  full_path = f'./zelda-graphics/1 - level/graphics/weapons/{player.weapon}/{direction}.png'
  self.image = pygame.image.load(full_path).convert_alpha() # convert_alpha para que no se vea transparente

 # placement
 if direction == 'right':
   self.rect = self.image.get_rect(midleft=player.rect.midright + pygame.math.Vector2(0,16)) # 16px relativos 
 elif direction == 'left':
   self.rect = self.image.get_rect(midright=player.rect.midleft + pygame.math.Vector2(0,16))
 elif direction == 'up':
   self.rect = self.image.get_rect(midbottom=player.rect.midtop + pygame.math.Vector2(-10,0))
 elif direction == 'down':
   self.rect = self.image.get_rect(midtop=player.rect.midbottom + pygame.math.Vector2(-10,0))

					3h 04 CREATING THE UI

Hay que crear la healthbar,la energy bar, la experience bar,el cargador de magic,etc.
Fijate en ciertas funciones básicas(pygame.draw.rect(surface,color,rect) para pintar un rectangulo
Fijate como en Python tengo que restar el self como argumento a la hora de contar los args de una funcion,es decir que def show(self,status,color) no tiene tres argumentos sino dos, cuando la llame solo la llamaré con show(status,color) 

TIP: pygame.display.get_surface() obtiene la referencia de la surface general(??) actual,por eso la estoy pasando en cada pygame.draw.rect(surface <- para que pinte en la surface actual
Surface es superficie

TIP: puedo inflar(o desinflar un rect(y otro tipo de figuras??) con inflate(x,y),por ejemplo si tengo un rect de 40x40 y le paso rect.inflate(10,10) será de 50x50.Fijate que rect no mutó,creo uno nuevo con otras dimensiones(y lo mismo para reducir una figura,le paso figura.inflate(-5,-5) y la haré un poco más pequeña.

Tips de hoy: puedo ponerme en modo siguiente ocurrencia con *(mayus + asterisk) o en modo anterior ocurrencia con #.Despues avanzo o retrocedo con n o con N.
Recuerda copiar con ciw y pegar con viwp

Puedo crear una figura cuadrática con pygame.Rect(left,top,ancho,alto).Esto creará un cuadrado de ancho x alto y a x pixeles del 0,0 segun left y top.Recuerda que en programacion la y va hacia abajo y restarla sería subir en la pantalla.
rect = pygame.Rect(10,10,50,50) <- crea un cuadrado de 50x50 a 10,10 de la esquina superior izquierda(pero ojo,que falta pintar el cuadrado).Para pintarlo necesito un color y una superficie:
pygame.draw.rect(self.display_surface,[20,20,20],rect)
Mas tips: en Python se niega con la keyword not, no hay un operador reservado aún ya que son muy prehistorics.Para agregar a una lista con append(es como el push) 
Fijate que centro la linea en la que esté con zz(muy útil,debo usarlo más)

			4H00 CREATING ENEMIES

Dado que el player y los enemies son similares podrán compartir métodos.Los métodos para moverse y colisionar son un buen ejemplo de esta casuística.
Para ello habrá que sacarlo de la clase Player y subirlos a una abstracción

Fijate como puedo comprobar con hasattr(Class,'prop') si un objeto/instancia tiene determinada propiedad:
def enemy_update(self,player):
  enemy_sprites = [sprite for sprite in self.sprites() if hasattr(sprite,'sprite_type') and sprite.sprite_type == "enemy"]
  for enemy in enemy_sprites:
    enemy.enemy_update(player)

para los sprites que tengan la propiedad sprite_type y sea de tipo 'enemy':
[sprite for sprite in self.sprites() if hasattr(sprite,'sprite_type) and ...

UNO :lo primero es coger el vector de cada rect que represente al player o a un enemy:
def get_player_distance_direction(self,player):
  enemy_vector = pygame.math.Vector2(self.rect.center)
  player_vector = pygame.math.Vector2(player.rect.center)
DOS: retorno la distancia(es un number resultante de calcular la hipotenusa del vector:
  distance = (player_vector - enemy_vector).magnitude()
TRES: retorno la dirección
 if distance > 0:
    direction = (player_vector - enemy_vector).normalize() 
 return (distance,direction)

* Fijate que este método realmente me valdría para calcular la distancia y dirección entre dos rect cualquiera que representen cualquier cosa,en este caso el player y los enemies.Normalize es obligatorio ya que el vector estará multiplicado por la self.speed del player

Luego hay que mirar el status del enemy para saber si se mueve o debe atacar,etc:
  def get_status(self,player):
    distance = self.get_player_distance_direction(player)[0]
    if distance <= self.attack_radius:
      self.status = 'attack'
    elif distance <= self.notice_radius:
      self.status = 'move'
    else:
      self.status = 'idle'

  def actions(self, player):
    if self.status == 'attack':
      print('attack')
    elif self.status == 'move':
      self.direction = self.get_player_distance_direction(player)[1]
    else:
      self.direction = pygame.math.Vector2(0,0)

Implemento los cooldowns,etc.

				4H57M PLAYER-ENEMIES INTERACTION

Esta interacción va a ir en dos direcciones,ya que ambos pueden atacarse mutuamente.Para ello creo dos grupos de sprites:

self.attack_sprites = pygame.sprite.Group()
self.attackable_sprites = pygame.sprite.Group()

Para comprobar si el player puede atacar,recuerda que al trabajar con sprites tengo el metodo estático pygame.sprite.spritecollide(quien,contraquien,matardeungolpe):

  def player_attack_logic(self):
    if self.attack_sprites:
      for attack_sprite in self.attack_sprites:
        # pygame.sprite.spritecollide(sprite,group,DOKILL)
        collision_sprites = pygame.sprite.spritecollide(attack_sprite,self.attackable_sprites,False)
        if collision_sprites:
          for target_sprite in collision_sprites:
            target_sprite.kill() 

De momento podemos matar a cualquier sprite con el que choquemos(target_sprite.kill()) aunque obviamente hay que mejorar esto.
Al mejorarlo queda asi:

  if target_sprite.sprite_type == 'grass':
    target_sprite.kill()
  else:
     target_sprite.get_damage(self.player,attack_sprite.sprite_type)

En este punto se introducen muchos métodos(seguir video).

				PARTICLES 5H33M

Una particle es simplemente un sprite con una animación.Es más sencillo de lo que parece,sólo que ese sprite se autodestruye cuando termina esa animación.

Dado que son muchas,lo que mejor es importarlas despues de que empiece el juego(es decir,tenerlas importadas de antemano),ya que si las importamos en el momento que el enemigo muera,etc se darán ralentizaciones

				SPELLS 5H56M

Vamos a crear una clase magic para la magia.Fijate que se necesitará el coste,fuerza del hechizo,animaciones,offsets,comprobar los stats...:

class MagicPlayer:
  def __init__(self,animation_player):
    self.animation_player = animation_player

  def heal(self,player,strength,cost,groups):
    
    if player.energy >= cost:
      player.health += strength
      player.energy -= cost
      if player.health >= player.stats['health']:
        player.health = player.stats['health']
      self.animation_player.create_particles('aura',player.rect.center,groups)
      self.animation_player.create_particles('heal',player.rect.center + pygame.math.Vector2(0,-50),groups)

  def flame(self,player,cost,groups):
    if player.energy >= cost:
      player.energy -= cost

    if player.status.split('_')[0] == 'right':
      direction = pygame.math.Vector2(1,0)
    elif player.status.split('_')[0] == 'left':
      direction = pygame.math.Vector2(-1,0)
    elif player.status.split('_')[0] == 'up':
      direction = pygame.math.Vector2(0,-1)
    else :
      direction = pygame.math.Vector2(0,1)

    for i in range(1,6):
      if direction.x: 
        #horizontal
        offset_x = (direction.x * i) * TILESIZE
        x = player.rect.centerx + offset_x + randint(-TILESIZE // 3, TILESIZE // 3)
        y = player.rect.centery + randint(-TILESIZE // 3, TILESIZE // 3)
        self.animation_player.create_particles('flame',(x,y),groups)
      else: #vertical
        offset_y = (direction.y * i) * TILESIZE
        x = player.rect.centerx + randint(-TILESIZE // 3, TILESIZE // 3)
        y = player.rect.centery + offset_y + randint(-TILESIZE // 3, TILESIZE // 3)
        self.animation_player.create_particles('flame',(x,y),groups)


				UPGRADES IN THE UI AND MENU 6H26M

1- The player needs to get xp from killing enemies
2- His stats should be increased due to this
Lo más complejo será actualizar la GUI.
7h05m
