				ZELDA STYLE GAME WITH PYGAMES LIB BY CLEAR-CODE

Source: https://www.youtube.com/watch?v=QU1pPzEGrqw&ab_channel=ClearCode
Repo: https://github.com/clear-code-projects/Zelda

					MINUTO 40 COLLISIONS

COLLISIONS: pygame puede decirme si ha ocurrido una colisión,pero no en que lado del sprite.Afortunadamente se puede solucionar,pero hay que tener esto en cuenta en pygame la direccion:
 
 def collision(self,direction):
    if direction == 'horizontal':
      pass <- haré algo
    if direction == 'vertical':
      pass <- haré otra cosa
Buscar el método collision en la clase Player para la impl.
También hubo que retocar def move:
  def move(self,speed):
    #si se mueve en diagonal hay que normalizar speed
    if self.direction.magnitude() != 0:
      self.direction = self.direction.normalize()
    # no uso self.speed ya que valdrá para mover cualquier cosa
    self.rect.x += self.direction.x * speed
    self.collision('horizontal')
    self.rect.y += self.direction.y * speed
    self.collision('vertical')
Más tarde crearemos un pequeño gap para que no se pare exactamente cuando empieza el sprite y dé la sensación de que hace overlap entre el sprite del player y el
del obstacle.
  
				MINUTO 50 CREATING THE CAMERA

NOTA: puedo conseguir la camara y el overlap anterior customizando un group.Hasta ahora sólo habiamos usado los grupos para:
1- Almacenar y dibujar sprites
2- Llamar al método update
*Sin embargo puedo añadir métodos o cambiar como funcionan los grupos

Fijate que es aqui donde los usé(level.py):
    # sprites group setup(visibles y colisionables)
    self.visible_sprites = pygame.sprite.Group()
    self.obstacle_sprites = pygame.sprite.Group()

Con todo esto puedo crear una clase para la Camara que herede de un Group:

class YSortCameraGroup(pygame.sprite.Group):  #extiende de Group
  def __init__(self):
    # general setup
    super().__init__()
    self.display_surface = pygame.display.get_surface()
    # saco los dos centros
    self.half_width = self.display_surface.get_size()[0] // 2
    self.half_height = self.display_surface.get_size()[1] // 2
    self.offset = pygame.math.Vector2()
    
  def custom_draw(self,player):
    # getting the offset
    self.offset.x = player.rect.centerx - self.half_width
    self.offset.y = player.rect.centery - self.half_height

    for sprite in self.sprites():
      offset_pos = sprite.rect.topleft - self.offset
      self.display_surface.blit(sprite.image,offset_pos)

			MINUTO 1H01 ADDING THE OVERLAP

Each sprite gets a hitbox for the collision.Nuestro objetivo es reducir un poco el hitbox para la collision con el player(a su cuerpo)
Para ello usaré inflate(x,y) que reduce el tamaño de un rectángulo:
self.hitbox = self.rect.inflate(0,-10) 
Aun faltó los overlaps.

			MINUTO 1H 10 USING PROPER GRAPHICS

En este punto el autor recalca que tiene un tutorial con Tiled(Un editor de screens para 2D).Es el tutorial de Mario.Esta sección será muy extensa:
1-La imagen
1h32
TIP: puedo caminar por el file system en python con el método walk de la lib os:
from os import walk

def import_folder(path):  
  for data in walk(path):
    print(data)

import_folder('./zelda-graphics/1 - level/map')
Pero,ojo,walk me devuelve tres argumentos,primero el nombre del folder,no lo quiero,despues una list con los subfolders(viene una empty list []),y como tercero viene una lista de files.Fijate que necesitaré combinar el path inicial con cada arg de la lista para crear el path completo para automatizar los imports:

			1H 56 PROPER PLAYER GRAPHICS AND ANIMATIONS

Turno del sprite para el player.Lo primero de todo es entender que el jugador va a tener varios estados(12 en total):
4 x idle,4 x walk, 4 x attack 
 Básicamente según el estado realizará una animación(habrá que importarlas pues).
También tendrá la habilidad de atacar y de magic input(??)

Para el ataque fisico y mágico necesitaré unos cooldowns:
Propiedades de PLAYER
    self.attacking = False
    self.attack_cooldown = 400
    self.attack_time = None

En def input(self)
    # attack input
    if keys[pygame.K_SPACE] and not self.attacking:
      self.attacking = True
      self.attack_time = pygame.time.get_ticks() 
    # magic input
    if keys[pygame.K_LCTRL] and not self.attacking:
      self.attacking = True
      self.attack_time = pygame.time.get_ticks() 

  def cooldowns(self):
    current_time = pygame.time.get_ticks() # este se llama multiples veces
    if self.attacking:
      if current_time - self.attack_time > self.attack_cooldown:
        self.attacking = False
        self.attack_time = None
    
NOTA: cada animación van a ser 5 sprites.Una vez dilucidado el status del player habrá que cargar esa secuencia de imagenes 
  def animate(self):
    animation = self.animations[self.status] # esto me da una lista o array
    # loop over the frame indexes
    self.frame_index += self.animation_speed
    if self.frame_index >= len(animation): # volver a empezar la animation
      self.frame_index = 0
    #set the image
    self.image = animation[int(self.frame_index)]
    self.rect = self.image.get_rect(center = self.hitbox.center) # hay que actualizar el cento por la diferencia de tamaño de las images

				2H30M WEAPONS

Básicamente crearemos un sprite cuando el jugador ataque y lo destruiremos cuando termine de atacar.
Para ello vamos a crear la clase Weapon en weapon.py, y al crear el player le pasamos una funcion create_attack:
    self.player = Player((2000,1430),[self.visible_sprites],self.obstacle_sprites,self.create_attack)
          
  def create_attack(self):
    Weapon(self.player,[self.visible_sprites]) 
    full_path = f'./zelda-graphics/1 - level/graphics/weapons/{player.weapon}/{direction}.png'
    self.image = pygame.image.load(full_path).convert_alpha() # convert_alpha para que no se vea transparente

    # placement
    if direction == 'right':
      self.rect = self.image.get_rect(midleft=player.rect.midright + pygame.math.Vector2(0,16)) # 16px relativos 
    elif direction == 'left':
      self.rect = self.image.get_rect(midright=player.rect.midleft + pygame.math.Vector2(0,16))
    elif direction == 'up':
      self.rect = self.image.get_rect(midbottom=player.rect.midtop + pygame.math.Vector2(-10,0))
    elif direction == 'down':
      self.rect = self.image.get_rect(midtop=player.rect.midbottom + pygame.math.Vector2(-10,0))

					3h 04 CREATING THE UI

Hay que crear la healthbar,la energy bar, la experience bar,el cargador de magic,etc.
Fijate en ciertas funciones básicas(pygame.draw.rect(surface,color,rect)
Fijate como en Python tengo que restar el self como argumento,es decir que
def show(self,status,color) <- no tiene tres argumentos sino dos,de echo cuando la llame solo la llamaré show(xxx,yyy) 

TIP: pygame.display.get_surface() obtiene la referencia de la surface actual,por eso la estoy pasando en cada pygame.draw.rect(surface <- para que pinte en la surface actual y no en la del vecino. 	
Surface es superficie

TIP: puedo inflar una figura con inflate(x,y),por ejemplo si tengo un rect de 40x40 y le paso rect.inflate(10,10) será de 50x50.Fijate que rect no mutó,creo uno nuevo con otras dimensiones(y lo mismo para reducir una figura,le paso figura.inflate(-5,-5) y la haré un poco más pequeña

Tips de hoy: puedo ponerme en modo siguiente ocurrencia con *(mayus + asterisk) o en modo anterior ocurrencia con #.Despues avanzo o retrocedo con n o con N.
Recuerda copiar con ciw y pegar con viwp

Puedo crear una figura cuadrática con pygame.Rect(left,top,ancho,alto).Esto creará un cuadrado de ancho x alto y a x pixeles del 0,0 segun left y top.Recuerda que en programacion la y va hacia abajo y restarla sería subir en la pantalla.
rect = pygame.Rect(10,10,50,50) <- crea un cuadrado de 50x50 a 10,10 de la esquina superior izquierda(pero ojo,que falta pintar el cuadrado).Para pintarlo necesito un color y una superficie:
pygame.draw.rect(self.display_surface,[20,20,20],rect)
Mas tips: en Python se niega con la keyword not, no hay un operador reservado aún ya que son muy prehistorics.Para agregar a una lista con append(como el push) 

Fijate que centro la linea en la que esté con zz(muy útil,debo usarlo más)

			4H00 CREATING ENEMIES

Dado que el player y los enemies son similares podrán compartir métodos.Los métodos para moverse y colisionar son un buen ejemplo de esta casuística.
Para ello habrá que sacarlo de la clase Player y subirlos a una abstracción
4h10m
