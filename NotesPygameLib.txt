				ZELDA STYLE GAME WITH PYGAMES LIB BY CLEAR-CODE

Source: https://www.youtube.com/watch?v=QU1pPzEGrqw&ab_channel=ClearCode

					MINUTO 40 COLLISIONS

COLLISIONS: pygame puede decirme si ha ocurrido una colisión,pero no en que lado del sprite.Afortunadamente se puede solucionar,pero hay que tener esto en cuenta en pygame la direccion:
 
 def collision(self,direction):
    if direction == 'horizontal':
      pass <- haré algo
    if direction == 'vertical':
      pass <- haré otra cosa
Buscar el método collision en la clase Player para la impl.
También hubo que retocar def move:
  def move(self,speed):
    #si se mueve en diagonal hay que normalizar speed
    if self.direction.magnitude() != 0:
      self.direction = self.direction.normalize()
    # no uso self.speed ya que valdrá para mover cualquier cosa
    self.rect.x += self.direction.x * speed
    self.collision('horizontal')
    self.rect.y += self.direction.y * speed
    self.collision('vertical')
Más tarde crearemos un pequeño gap para que no se pare exactamente cuando empieza el sprite y dé la sensación de que hace overlap entre el sprite del player y el
del obstacle.
  
				MINUTO 50 CREATING THE CAMERA

NOTA: puedo conseguir la camara y el overlap anterior customizando un group.Hasta ahora sólo habiamos usado los grupos para:
1- Almacenar y dibujar sprites
2- Llamar al método update
*Sin embargo puedo añadir métodos o cambiar como funcionan los grupos

Fijate que es aqui donde los usé(level.py):
    # sprites group setup(visibles y colisionables)
    self.visible_sprites = pygame.sprite.Group()
    self.obstacle_sprites = pygame.sprite.Group()

Con todo esto puedo crear una clase para la Camara que herede de un Group:

class YSortCameraGroup(pygame.sprite.Group):  #extiende de Group
  def __init__(self):
    # general setup
    super().__init__()
    self.display_surface = pygame.display.get_surface()
    # saco los dos centros
    self.half_width = self.display_surface.get_size()[0] // 2
    self.half_height = self.display_surface.get_size()[1] // 2
    self.offset = pygame.math.Vector2()
    
  def custom_draw(self,player):
    # getting the offset
    self.offset.x = player.rect.centerx - self.half_width
    self.offset.y = player.rect.centery - self.half_height

    for sprite in self.sprites():
      offset_pos = sprite.rect.topleft - self.offset
      self.display_surface.blit(sprite.image,offset_pos)

			MINUTO 1H01 ADDING THE OVERLAP

Each sprite gets a hitbox for the collision.Nuestro objetivo es reducir un poco el hitbox para la collision con el player(a su cuerpo)
Para ello usaré inflate(x,y) que reduce el tamaño de un rectángulo:
self.hitbox = self.rect.inflate(0,-10) 
Aun faltó los overlaps.

			MINUTO 1H 10 USING PROPER GRAPHICS

En este punto el autor recalca que tiene un tutorial con Tiled(Un editor de screens para 2D).Es el tutorial de Mario.Esta sección será muy extensa:
1-La imagen
1h32
TIP: puedo caminar por el file system en python con el método walk de la lib os:
from os import walk

def import_folder(path):  
  for data in walk(path):
    print(data)

import_folder('./zelda-graphics/1 - level/map')
Pero,ojo,walk me devuelve tres argumentos,primero el nombre del folder,no lo quiero,despues una list con los subfolders(viene una empty list []),y como tercero viene una lista de files.Fijate que necesitaré combinar el path inicial con cada arg de la lista para crear el path completo para automatizar los imports:

			1H 56 PROPER PLAYER GRAPHICS AND ANIMATIONS

Turno del sprite para el player.Lo primero de todo es entender que el jugador va a tener varios estados(12 en total):
4 x idle,4 x walk, 4 x attack 
 Básicamente según el estado realizará una animación(habrá que importarlas pues).
También tendrá la habilidad de atacar y de magic input(??)

Para el ataque fisico y mágico necesitaré unos cooldowns:
Propiedades de PLAYER
    self.attacking = False
    self.attack_cooldown = 400
    self.attack_time = None

En def input(self)
    # attack input
    if keys[pygame.K_SPACE] and not self.attacking:
      self.attacking = True
      self.attack_time = pygame.time.get_ticks() 
    # magic input
    if keys[pygame.K_LCTRL] and not self.attacking:
      self.attacking = True
      self.attack_time = pygame.time.get_ticks() 

  def cooldowns(self):
    current_time = pygame.time.get_ticks() # este se llama multiples veces
    if self.attacking:
      if current_time - self.attack_time > self.attack_cooldown:
        self.attacking = False
        self.attack_time = None
    
NOTA: cada animación van a ser 5 sprites.Una vez dilucidado el status del player habrá que cargar esa secuencia de imagenes 
  def animate(self):
    animation = self.animations[self.status] # esto me da una lista o array
    # loop over the frame indexes
    self.frame_index += self.animation_speed
    if self.frame_index >= len(animation): # volver a empezar la animation
      self.frame_index = 0
    #set the image
    self.image = animation[int(self.frame_index)]
    self.rect = self.image.get_rect(center = self.hitbox.center) # hay que actualizar el cento por la diferencia de tamaño de las images

				2H30M WEAPONS

Básicamente crearemos un sprite cuando el jugador ataque y lo destruiremos cuando termine de atacar.
Para ello vamos a crear la clase Weapon en weapon.py, y al crear el player le pasamos una funcion create_attack:
    self.player = Player((2000,1430),[self.visible_sprites],self.obstacle_sprites,self.create_attack)
          
  def create_attack(self):
    Weapon(self.player,[self.visible_sprites]) 
    full_path = f'./zelda-graphics/1 - level/graphics/weapons/{player.weapon}/{direction}.png'
    self.image = pygame.image.load(full_path).convert_alpha() # convert_alpha para que no se vea transparente

    # placement
    if direction == 'right':
      self.rect = self.image.get_rect(midleft=player.rect.midright + pygame.math.Vector2(0,16)) # 16px relativos 
    elif direction == 'left':
      self.rect = self.image.get_rect(midright=player.rect.midleft + pygame.math.Vector2(0,16))
    elif direction == 'up':
      self.rect = self.image.get_rect(midbottom=player.rect.midtop + pygame.math.Vector2(-10,0))
    elif direction == 'down':
      self.rect = self.image.get_rect(midtop=player.rect.midbottom + pygame.math.Vector2(-10,0))

					3h 04 CREATING THE UI

Hay que crear la healthbar,la energy bar, la experience bar,el cargador de magic,etc.
